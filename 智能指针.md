Rust 中最常见的指针类型是引用。引用由 & 符号表示，并借用它们指向的值。除了引用数据以外没有特殊功能和开销。

智能指针是像指针一样工作的数据结构并且包含额外的元数据和功能。例如引用计数智能指针类型，它允许一个数据有多个所有者并跟踪所有者的数量，当没有所有者时再释放数据内存。引用只借用数据，多数情况下，智能指针拥有他们指向的数据。

我们实际已经遇到了一些智能指针，包括 String 和 `Vec<T>`，这两种类型都算作智能指针，因为它们拥有一些内存并允许对其进行操作。

智能指针通常使用 struct 来实现，并且实现了 Deref 和 Drop 特征。Deref 特性允许智能指针结构的实例表现得像引用，使得可以编写代码同时支持引用和智能指针。Drop 特性允许你自定义在智能指针实例超出作用域时运行的代码。

## 使用 `Box<T>` 指向堆上的数据

最简单的智能指针是 `Box<T>`。Box 允许你在堆上存储数据，并在栈上存储指针指向堆上的值。Box 没有其它的功能。经常使用在以下场景：

- 当你有一个数据类型，编译时无法知道其大小，但需要在运行时的上下文环境中知道其准确大小。
- 当你有大量的数据，你想转移所有权但不想复制所有数据的时候。
- 当你想拥有一个值并且你只关心它是一个实现特定特征的类型而不是某个特定类型时。

### 使用 `Box<T>` 在堆上存储数据

如何使用 Box 在堆上存储 i32 值：

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

5 被分配到了堆上，指向 5 的 Box 的实例分配给变量 b。我们可以像访问栈上的数据一样访问 b。当 b 超出作用域，即 main 函数结束的时候，栈上的指针值和堆上的数据都会被释放。

### 用 Box 启用递归类型

编译时 Rust 需要知道一个类型占用了多少空间。然而，递归类型的值的嵌套在理论上可以无限继续，所以 Rust 无法知道值需要多少空间。Box 可以解决这个问题。

#### 递归类型 Cons 列表

_cons list_ 由嵌套数据对组成。下面为一个包含 1, 2, 3 的 cons 列表：

```text
(1, (2, (3, Nil)))
```

组成 cons 列表的每一个条目包含两个元素。cons 列表是通过递归调用 cons 函数生成的。列表中的最后一项仅包含一个名为 Nil 的值。

用枚举类型定义一个 cons 列表，注意以下代码不能通过编译，后面会解释原因。

```rust
enum List {
    Cons(i32, List),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

非递归变体 Nil 意味着列表的结束。编译会提示 List 枚举的尺寸可以无限大。Rust 无法计算出它需要多少空间来存储一个 List 值。我们需要先了解 Rust 如何决定存储一个值的空间大小来解释 Rust 无法计算的原因。

#### 计算类型所需的空间的大小

回顾之前定义的枚举 Message：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

为了决定分配给 Message 值的空间大小，Rust 遍历 Message 的每一个变体，因为 Message 的值只可能是其中某一个变体，所以分配给 Message 值的空间大小就是 Message 变体中最大的变体所需的空间。

反观 List，Rust 先计算变体 Cons 的所需空间大小，等于 i32 的大小加上 List 的大小，而 List 又有一个 Cons 变体需要 i32 的大小加上 List 的大小的空间，这个过程会无限地持续下去。因此是无限大的。

#### 使用 `Box<T>` 限制空间大小

因为 Rust 无法计算出需要为递归定义的类型分配多少空间，所以我们可以更改数据结构以通过存储指向值的指针来间接存储值。

因为 `Box<T>` 是一个指针，Rust 总是知道 `Box<T>` 需要多少空间，因为指针的大小不会因为被指向的值的大小而改变。我们可以间接的将指向 List 的 `Box<T>` 放在 Cons 变体中。被指向的 List 将会存储在堆中。如下：

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```

现在 Cons 变体需要 i32 的大小加上存储 box 指针数据的空间。Nil 变体不存储任何值，比 Cons 的空间小，所以 List 的值的空间大小就确定了。编译器可以计算出存储 List 值所需的大小了。

## 使用 Deref 特征将智能指针视为常规引用

实现了 `Deref` 特征的智能指针可以被视为常规引用，因此对引用操作的代码对智能指针同样适用。

我们先定义一个行为类似于 `Box<T>` 的智能指针，然后实现 `Deref` 特征，使其可以被视为常规引用。

常规引用是一种指针，可以通过解引用运算符 \* 获得该指针指向的值。

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

我们必须使用 `*y` 来获取 y 指向的值，然后再和 5 进行比较。

以上代码可以使用 `Box<T>` 来替代引用，将解引用运算符用在 `Box<T>` 上，如下：

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

这里 y 等于一个 `Box<T>` 的实例，该智能指针指向 x 的复制值而不是 x 的引用。然后用解引用运算符 \* 类似于对常规引用一样的操作获取指向的值。

### 定义我们自己的智能指针

自定义一个类似于 `Box<T>` 的智能指针，逐步了解如何使其可以使用解引用操作符。

`MyBox<T>` 和 `Box<T>` 一样是一个仅有一个元素元组结构体。

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```

用 `MyBox<T>` 替换刚才代码中的 `Box<T>` ：

```rust
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

这里编译会报错，因为  `MyBox<T>` 类型不能被解引用，必须实现  `Deref` 特征。

### 实现 Deref 特征

Deref 特征需要我们实现一个方法 deref，并返回内部值的引用。如下：

```rust
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

`self.0` 返回的是元组结构体中的第一个值， `&self.0` 返回该值的引用。实现 Deref 特征后， 对 `MyBox<T>` 进行  `*` 运算就可以了。

当我们运行 `*y` 时，Rust 实际上运行如下代码：

```rust
*(y.deref())
```

Rust 将 `*` 运算符替换为 deref 方法，然后对返回值进行解引用。这个特征使得我们可以将实现 Deref 特征的类型视作常规引用。

### Deref coercion

Rust 实现了 _Deref coercion_ ，它可以将对某种实现 Deref 的引用转换成对第一种类型的引用。例如可以将 `&String` 转换成 `&str`，对 Rust 函数和方法的参数设计提供了便利。当给函数或方法传递某个类型的引用作为参数时，如果与所需的参数类型不匹配， _Deref coercion_ 自动执行。

首先定义一个接收字符串切片的函数：

```rust
fn hello(name: &str) {
    println!("Hello, {name}!");
}
```

我们可以使用字符串切片调用该函数，例如 hello("Rust")，而 _Deref coercion_ 可以通过传递 `MyBox<String>` 的引用调用该函数。

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

因为 MyBox 实现了 Deref 特征。Rust 通过调用 deref 方法将 `&MyBox<String>` 转变为  `&String`。同时标准库函数对 String 类型也实现了 Deref 特征。 Rust 再次调用 deref 方法将 `&String` 转变为 `&str` 。这时候就与 hello 函数的参数定义匹配了。
